name: shell and yaml lint check

on:
  workflow_call:
    inputs:
      repo:
        type: string
        required: true
        description: '检查的代码仓库来源'
      ref: 
        type: string
        required: true
        description: '拉取分支'
      check_path:
        type: string
        default: '.'
        description: '要检查的目录或文件, 每行一个'
    outputs:
      summary_content: 
        value: ${{ jobs.collect-info.outputs.summary }}

  
jobs:
  code-lint:
    if: ${{ inputs.check_path }}
    outputs:
      shellcheck_result: ${{ steps.check.outputs.shellcheck_result }}
      yamllint_result: ${{ steps.check.outputs.yamllint_result }}
    runs-on: 'ubuntu-latest'
    strategy:
      matrix:
        check_type: [shellcheck, yamllint]
    steps:
      - uses: actions/checkout@v4
        with:
          repository: ${{ inputs.repo }}
          ref: ${{ inputs.ref }}

      - name: install depends
        run: |
          sudo apt-get update
          if [ "${{ matrix.check_type }}" = "shellcheck" ]; then
            sudo apt-get install shellcheck
          elif [ "${{ matrix.check_type }}" = yamllint ]; then
            sudo apt-get install python3-pip
            sudo pip3 install yamllint
            yamllint -h
          fi

      - name: ${{ matrix.check_type }}
        id: check
        shell: bash
        continue-on-error: true
        env:
          check_path: ${{ inputs.check_path }}
          check_type:  ${{ matrix.check_type }}
        run: |
          set -x

          check_path="${check_path}
          "

          set +e
          while read -r l; do
            if [ ! -d "$l" ] && [ ! -f "$l" ]; then continue; fi
            case "$check_type" in
              shellcheck)
                find "$l" -type f -name "*.sh"
                ;;
              yamllint)
                "$check_type" --list-files "$l"
                ;;
              esac
          done <<< $check_path > need_check_files
          
          cat need_check_files
          
          declare -A all_msg_type=()
          file_cnt=0
          while read -r file; do
            if [ ! -f "$file" ]; then continue; fi
            
            case "$check_type" in
              shellcheck)
                "$check_type" "$file" -f gcc
                ;;
              yamllint)
                "$check_type" -f parsable "$file"
                ;;
            esac > parse_result

            declare -A msg_cnt=()
            
            while read -r f msgtype info; do
              if [ "$f" = "" ] || [ "$msgtype" = "" ]; then continue; fi
              file_cnt=$((file_cnt + 1))
              k="${msgtype%:}"
              msg_cnt["${k}"]=$(( "${msg_cnt["${k}"]:-0}" + 1 ))
              all_msg_type["${k}"]=$((${all_msg_type["${k}"]:-0} + 1))
            done < parse_result
            info=$(for k in "${!msg_cnt[@]}"; do echo -n "$k: ${msg_cnt[$k]}, "; done)
            info=${info:-[ok]}
            echo "| $file | ${info%,*} |"

          done < need_check_files > info_result

          cat info_result

          cat > summary << EEE
          ### $check_type result
          
          check_path:
          
          $(while read -r l; do [ "$l" != "" ] && echo "- $l"; done <<< "$check_path")
          
          ***$check_type $(for k in "${!all_msg_type[@]}"; do echo -n "$k: ${all_msg_type[$k]}, "; done) in ${file_cnt} files.***

          | file | message count |
          |:-|:-:|
          $(cat info_result)
          
          EEE
          echo "${check_type}_result<<EOF" >> $GITHUB_OUTPUT
          cat summary >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

          {
          cat summary
          echo '```log'
          while read -r l; do
            if [ ! -d "$l" ] && [ ! -f "$l" ]; then continue; fi
            echo "check $l"

            case "$check_type" in
              shellcheck)
                find "$l" -type f -name "*.sh" -exec "$check_type" {} \;
                ;;
              yamllint)
                "$check_type" -f standard "$l"
                ;;
            esac
          done <<< "$check_path"
          echo '```'
          } >> $GITHUB_STEP_SUMMARY

  collect-info:
    outputs:
      summary: ${{ steps.summary.outputs.summary }}
    needs: [code-lint]
    runs-on: 'ubuntu-latest'
    steps:
      - id: summary
        run: |
          echo "summary<<EOF" >> $GITHUB_OUTPUT
          cat >> $GITHUB_OUTPUT << EEE

          ## Code lint and check Result

          ${{ needs.code-lint.outputs.shellcheck_result }}

          ${{ needs.code-lint.outputs.yamllint_result }}

          EEE

          echo "EOF" >> $GITHUB_OUTPUT




  